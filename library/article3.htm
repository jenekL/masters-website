<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>ИСПОЛЬЗОВАНИЕ OPENCV В РАМКАХ ЗАДАЧИ ОФФЛАЙН РАСПОЗНАВАНИЯ РУКОПИСНОГО ТЕКСТА</title>
    <link rel="stylesheet" type="text/css" href="../css/files/articles.css">
</head>
<body>

<div id="topblock">
    <a href="index.htm">Назад в библиотеку</a>
    <br>
    <hr>
</div>
<div>
    <h2 style="text-align: center">ИСПОЛЬЗОВАНИЕ OPENCV В РАМКАХ ЗАДАЧИ ОФФЛАЙН РАСПОЗНАВАНИЯ РУКОПИСНОГО ТЕКСТА</h2>
    <p>Басанько А.С., Рыбкин С.В.</p>
    <p>1Калужский филиал ФГБОУ ВО «Московский государственный технический университет им. Н.Э. Баумана (национальный
        исследовательский университет)», Калуга, e-mail: fn1-kf@mail.ru</p>
    <p><i>Данная статья посвящена использованию библиотеки OpenCV в рамках решения задачи оффлайн распознавания рукописного
    текста. Данная задача обычно состоит из множества этапов. Этапы предварительной обработка изображения и сегментации
    являются одними из них. Библиотека OpenCV является достаточно мощным инструментом и вполне позволяет решить задачи
    этих двух этапов с хорошим результатом. OpenCV содержит реализации множества алгоритмов различных типов:
    распознавание объектов, устранение искажений, выявление сходства и формы объектов, отслеживание перемещения объекта,
    распознавание движений и жестов. Для предобработки изображений имеется множество методов, в том числе реализации
    фильтра Гаусса и медианного фильтра, метод преобразования изображения в градации серого, а также метод пороговой
    бинаризации. Также OpenCV имеет поддержку морфологических операций, посредством применения которых можно выделить
    слова на изображении. Таким образом, в данной статье будет подробно описано, каким образом можно объединить
    несколько методов, реализуемых в библиотеке OpenCV, для решения задач предобработки изображения и выделения на нём
    слов в рамках задачи оффлайн распознавания рукописного текста, а также каких результатов с этим можно достигнуть.</i></p>
    <p>Ключевые слова: распознавание рукописного текста, OpenCV, выделение рукописных слов, обработка изображений</p>

    <b>Введение.</b>
    <p>Задача оффлайн распознавания рукописного текста, как правило, состоит из нескольких этапов:
    предварительная обработка, сегментация, извлечение признаков, классификация и обработка результатов.
    В рамках данной статьи сосредоточимся на первых двух этапах. На этапе предварительной обработки происходит обработка
    изображения с целью повышения его качества и приведения его к виду, удобному для сегментации. Этап сегментации
    подразумевает выделение текста на изображении и его разделение на составные части. Обычно текст обрабатывается
    иерархически: сначала выделяются отдельные строки, затем отдельные слова, затем символы или части символов.</p>

    <p>Для реализации двух первых этапов оффлайн распознавания рукописного текста можно воспользоваться таким инструментом,
        как OpenCV.</p>
    <p>OpenCV представляет собой библиотеку компьютерного зрения с открытым исходным кодом, которая разработана компанией
    Intel на языке программирования C/C++. Также существуют версии этой библиотеки и для других языков, таких как
    Python, Java, С#, MatLab и многих других. В данной библиотеке реализовано множество алгоритмов следующих типов [1,
        2]:</p>
    <ul>
    <li>Распознавание объектов;
    <li>Распознавание печатного текста;
    <li>У странение искажений;
    <li>Выявление сходства и формы объектов;
    <li>Отслеживание перемещение объекта;
    <li>Распознавание движений, жестов.
    Предварительная обработка изображения. Этап предварительной обработки изображения обычно состоит из следующих задач
    [3, 4]:
    <li>Преобразование изображения в градации серого;
    <li>Удаление дефектов.
    </ul>

    <img src="images/3/image%20(7).png" alt="Рисунок 1" class="center">
    <p class="caption">Рисунок 1. Карта проекта OpenCV</p>

    <p>Изображение в OpenCV представляется с помощью класса Image [5]. При создании
    объекта этого класса необходимо указать путь к изображению. Для решения задачи преобразования изображения в градации
    серого достаточно вызвать метод Convert и указать конечный цвет изображения, в данном случае цвет Gray. Результат
    обработки можно увидеть на Рис.2.
    Пример исходного кода, написанного на языке C#, с помощью библиотеки Emgu.CV, которая является оберткой под .NET
    платформу над оригинальной библиотекой OpenCV:</p>

    <p>var img = new Image
    <Bgr, byte>(filePath);
    var grayImage = img.Convert
        <Gray, byte>();</p>

    <img src="images/3/image%20(8).png" alt="Рисунок 2" class="center">
    <p class="caption">Рисунок 2.Преобразование изображения в градации серого.</p>

    <p> Удаление дефектов подразумевает собой применение различных фильтров для удаления шумов. Наиболее часто используемыми
    фильтрами являются фильтр Гаусса для подавления высокочастотного шума и медианный фильтр для удаления шума «соль и
        перец».</p>
    <p>Реализации этих фильтров также есть в OpenCV.</p>
    <p>Для использования фильтра Гаусса достаточно воспользоваться функцией
    GaussianBlur поместив в качестве параметров входное и выходное изображения, размер ядра Гаусса, величины отклонения
    ядра Гаусса по осям X и Y, а также метод экстраполяции пикселей [6]. Под ядром Гаусса понимается матрица свертки,
    которая помогает для каждого пикселя изображения рассчитать средневзвешенное значение соседних пикселей. В
    результате чего все зашумленные пиксели (яркость которых сильно отличается от яркости соседних пикселей) примут
    усредненное значение. Ширина и высота ядра могут отличаться, но они оба должны быть положительными и нечетными.
    Также они могут быть равны 0, что будет означать, что размер ядра будет рассчитываться исходя из величины отклонения
        ядра Гаусса.</p>
    <p>В свою очередь для использования медианного фильтра необходимо воспользоваться функцией MedianBlur поместив в
    качестве параметров входное и выходное изображения, размер окна (апертуры), которое должно быть нечётным. Результат
        применения медианного фильтра можно увидеть на Рис.3.</p>

    <p>Пример исходного кода:</p>

    CvInvoke.MedianBlur(grayImage, grayImage, 5);
    CvInvoke.GaussianBlur(grayImage, grayImage, new Size(5, 5),
    1.5, 0, BorderType.Replicate);

    <p>Выделение слов на изображении. Как уже было сказано выше, следующим этапом в оффлайн распознавании рукописного
    текста является этап сегментации. Основная задача этого этапа – выделение текста на изображении. Если пренебречь
    тем, что рукописный текст может быть написан под различным наклоном, то с помощью OpenCV можно сразу выделять строки
        и слова, находящиеся в каждой из строк.</p>

    <img src="images/3/image%20(71).png" alt="Рисунок 3" class="center">
    <p class="caption">Рисунок 3. Результат применения медианного фильтра.</p>

    <p>Процесс выделения слов при помощи OpenCV можно разделить на следующие этапы:</p>
    <ul>
    <li>Пороговая бинаризация изображения;
    <li>Применение операции морфологического замыкания;
    <li>Выделение границ слов.
    </ul>
    <p>Метод пороговой бинаризации осуществляется при помощи функции Threshold, которая принимает на вход изображение в
    градациях серого, выходное изображение, величину порога и алгоритм вычисления порога. Наиболее известным алгоритмом
    вычисления порога является метод Оцу [7]. В результате бинаризации получаем изображения белого текста на черном фоне
        (Рис. 4).</p>

    <p>Пример исходного кода:</p>

    var thresholdImage = new Image
    <Gray , byte>(grayImage.Size);
    CvInvoke.Threshold(grayImage, thresholdImage, 0, 255,
    ThresholdType.Otsu);

        <p>Для того чтобы на последнем этапе выделить слова с изображения, необходимо воспользоваться морфологической операцией
    замыкания [8]. Для этого служит функция MorphologyEx, принимающая на вход изображение, полученное на предыдущем этапе, выходное изображение, тип
    морфологической операции (в данном случае операция замыкания) и структурный элемент, с которым будет осуществляться
    операция. В качестве структурного элемента обычно используют прямоугольник. Результат применения морфологической
            операции замыкания можно увидеть на Рис. 5. </p>

        <p>Пример исходного кода:</p>

        var element = CvInvoke.GetStructuringElement(
    ElementShape.Rectangle, new Size(5, 5), new Point(0, 0));
    CvInvoke.MorphologyEx(thresholdImage, thresholdImage,
    MorphOp.Close, element, new Point(-1, -1), 12, BorderType.Default,
    new MCvScalar());

    <img src="images/3/image%20(9).png" alt="Рисунок 4" class="center">
    <p class="caption">Рисунок 4. Результат пороговой бинаризации.</p>

        <p>Наконец, на последнем этапе выделяются слова на изображении. Для этого
    используются функции FindContours, которая находит все контуры слов на бинарном изображении и функция
    BoundingRectangle, которая возвращает ограничивающий прямоугольник для каждого слова на основе контура. В
            результате, с помощью этих прямоугольников мы можем выделить слова на конечном изображении (Рис. 6).</p>

        <p>Пример исходного кода:</p>

        var contours = new VectorOfVectorOfPoint();
    var rects = new List<Rectangle/>();
        CvInvoke.FindContours(thresholdImage, contours, null,
        RetrType.External, ChainApproxMethod.ChainApproxSimple);
        for (var i = 0; i < contours.Size; i++)
        {
        var approxContour = new VectorOfPoint();
        CvInvoke.ApproxPolyDP(contours[i], approxContour, 0.005, true);
        if (CvInvoke.ContourArea(approxContour) > 100)
        {
        var boundingRectangle = CvInvoke.BoundingRectangle
        (approxContour);
        rects.Add(boundingRectangle);
        }
        }

        <img src="images/3/image%20(10).png" alt="Рисунок 5" class="center">
        <p class="caption">Рисунок 5. Результат морфологической операции замыкания.</p>

        <img src="images/3/image%20(11).png" alt="Рисунок 6" class="center">
        <p class="caption">Рисунок 6. Выделенные слова на изображении.</p>

            <p><b>Заключение.</b></p>
            <p>Таким образом, в данной статье было рассмотрено использование
        открытой библиотеки OpenCV для предобработки изображения и выделения слов на изображении в рамках задачи оффлайн
        распознавания рукописного текста. Данная библиотека справляется с этой задачей достаточно качественно и быстро.</p>
            <p><b>Список использованной литературы:</b></p>
        <ol>
            <li>Разин И.Б., Миронов В.П., Муртазина А.Р., Оганезов К.В. Применение библиотеки OpenCV в системах
                автоматизированного проектирования // Дизайн, технологии и инновации в текстильной и легкой
                промышленности. Сборник материалов международнойнаучно-технической конференции. Федеральное
                государственное бюджетное образовательное учреждение высшего профессионального образования «Московский
                государственный университет дизайна и технологии». 2015. С. 244-246. [Электронный ресурс] URL:
                https://elibrary.ru/download/elibrary_24392430_45225961.pdf (дата обращения: 21.11.2018)
            <li>Медведев А.А., Пакулич Д.В. Изучение возможностей библотеки OpenCV для обработки изображений //
                Математика. Информатика. Компетентностный подход к обучению в вузе и школе. Сборник материалов
                всероссийской научно-практической конференции. 2015. С. 103-104. [Электронный ресурс] URL:
                https://elibrary.ru/download/elibrary_29267849_47839333.pdf (дата обращения: 14.11.2018)
            <li>Басанько А.С., Белов Ю.С. Основные методы обработки изображений при оффлайн распознавании рукописного
                текста // Научное обозрение. Технические науки – 2018. - No3 - с. 5-8. [Электронный ресурс] URL:
                https://science-engineering.ru/ru/article/view?id=1184 (дата обращения: 11.11.2018)
            <li>Басанько А.С., Рыбкин С.В. Существующие проблемы распознавания рукописного текста // В сборнике: Научные
                исследования в области технических и технологических систем. Сборник статей Международной
                научно-практической конференции. 2018. С. 25-28.
            <li>Yue Yaru, Zhu Jialin Algorithm of fingerprint extraction and implementation based on OpenCV // 2nd
                International Conference on Image, Vision and Computing (ICIVC). 2017. P.163- 167. [Электронный ресурс]
                URL: https://ieeexplore.ieee.org/document/7984539 (дата обращения: 05.11.2018)
            <li>Нанавова Т.А. Алгоритм извлечения текста из видео с использованием библиотеки компьютерного зрения
                OpenCV // Ростовский научный журнал. 2016. No 7. С. 21-40. [Электронный ресурс] URL:
                https://elibrary.ru/download/elibrary_26376289_32767465.pdf (дата обращения: 11.11.2018)
            <li>Ширабоков И.А., Щелканов А.В., Чумаченко И.М. Использование пороговых фильтров в OpenCV // Россия
                молодая: передовые технологии – в промышленность!. 2015. No 2. С. 86-89. [Электронный ресурс] URL:
                https://elibrary.ru/download/elibrary_25004826_7617 9940.pdf (дата обращения: 25.10.2018)
            <li>Гришанов К.М., Белов Ю.С. Морфологические операции для уменьшения шума на изображении // Электронный
                журнал: наука, техника и образование. 2016. No 2 (6). С. 90-95. [Электронный ресурс] URL:
                https://elibrary.ru/download/elibrary_26847525_60281350.pdf (дата обращения: 11.11.2018)
        </ol>
</body>
</html>